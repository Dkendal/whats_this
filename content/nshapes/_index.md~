+++
title = "Numbers and Shapes"
author = ["Alasdair McAndrew"]
draft = false
+++

## Numbers and Shapes {#numbers-and-shapes}

This is the holding place for my old blog, when I import it from Wordpress.  In
the meantime, it's [here](<https://numbersandshapes.net>)


## Presentations and the delight of js-reveal {#presentations-and-the-delight-of-js-reveal}

Presentations are a modern bugbear. Anybody in academia or business, or
any professional field really, will have sat through untold hours of
presentations. And almost all of them are _terrible_. Wordy,
uninteresting, too many "transition effects", low information content,
you know as well as I do.

Pretty much every speaker reads the words on their slides, as though the
audience were illiterate. I went to a talk once which consisted of 60 --
yes, sixty -- slides of very dense text, and the presenter read through
each one. I think people were gnawing their own limbs off out of sheer
boredom by the end.
[Andy Warhol's
"Empire"](https://en.wikipedia.org/wiki/Empire_(1964_film)) would have been a welcome relief.

Since most of my talks are technical and full of mathematics, I have
naturally gravitated to the LaTeX presentation tool
[Beamer](https://en.wikipedia.org/wiki/Beamer_(LaTeX)). Now Beamer is
a lovely thing for LaTeX: as part of the LaTeX ecosystem you get all of
LaTeX loveliness along with elegant slide layouts, transitions, etc. My
only issue with Beamer (and this is not a new observation by any means),
is that all Beamer presentations have a certain sameness to them. I
suspect that this is because most Beamer users are mathematicians, who
are rightly more interested in co[[<https://orgmode.org>][]]ntent than
appearance. It is quite possible of course to make Beamer look like
something new and different, but hardly anybody does.

However, I am not a mathematician, I am a mathematics educator, and I do
like my presentations to look good, and if possible to stand out a
little. I also have a minor issue in that I use Linux on my laptop,
which sometimes means my computer won't talk to an external projector
system. Or my USB thumb drive won't be recognized by the computer I'll
be using, and so on. One way round all this is to use an online system;
maybe one which can be displayed in a browser, and which can be placed
on a web server somewhere. There are of course plenty of such tools, and
I have had a brief dalliance with [prezi](https://prezi.com), but for
me prezi was not the answer: yes it was fun and provided a new paradigm
for organizing slides, but really, when you took the whizz-bang aspect
out, what was left? The few prezis I've seen in the wild showed that you
can be as dull with prezi as with any other software. Also, at the time
it didn't support mathematics.

In fact I have an abiding distrust of the whole concept of
"presentations". Most are a colossal waste of time -- people can read so
there's no need for wordiness, and most of the graphs and charts that
make up the rest of most slides are dreary and lacklustre. Hardly
anybody knows how to present information graphically in a way that
really grabs people's attention. It's lazy and insulting to your
audience to simply copy a chart from your spreadsheet and assume they'll
be delighted by it. Then you have the large class of people who fill
their blank spaces with cute cartoons and clip art. This sort of thing
annoys me probably more than it should -- when I'm in an audience I
don't want to be entertained with cute irrelevant additions, I want to
_learn_. This comes to the heart of presenting. A presenter is acting as
a teacher; the audience the learners. So presenting should be about
engaging the audience. What's in your slides comes a distant second. I
don't want new technology with clever animations and transitions,
bookmarks, non-linear slide shows; I want presenters to be themselves
interesting. (As an aside, some of the very worst presentations have
been at education conferences.)

For a superb example of attention-grabbing graphics, check out the
[TED
talk](https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen) by the late [Hans
Rosling](https://en.wikipedia.org/wiki/Hans_Rosling). Or you can admire the work of
[David McCandless](https://informationisbeautiful.net).

I seem to have digressed, from talking about presentation software to
banging on about the awfulness of presentations generally. So, back to
the topic.

For a recent conference I determined to do just that: use an online
presentation tool, and I chose [reveal.js](https://revealjs.com/#/). I
reckon reveal.js is presentations done right: elegant, customizable,
making the best use of html for content and css for design; and with
nicely chosen defaults so that even if you just put a few words on your
slides the result will still look good. Even better, you can take your
final slides and put them up on [github
pages](https://pages.github.com) so that you can access them from anywhere in the world with a
web browser. And if you're going somewhere which is not networked, you
can always take your slides on some sort of portable media. And it has
access to almost all of LaTeX via [MathJax](https://www.mathjax.org).

One minor problem with reveal.js is that the slides are built up with
raw html code, and so can be somewhat verbose and hard to read (at least
for me). However, there is a companion software for emacs org mode
called [org-reveal](https://github.com/yjwen/org-reveal), which
enables you to structure your reveal.js presentation as an org file.
This is presentation heaven. The org file gives you structure, and
reveal.js gives you a lovely presentation.

To make it available, you upload all your presentations to github.pages,
and you can present from anywhere in the world with an internet
connection! You can see an example of one of my short presentations at

<https://amca01.github.io/ATCM_talks/lindenmayer.html>

Of course the presentation (the software and what you do with it), is in
fact the least part of your talk. By far the most important part is the
presenter. The best software in the world won't overcome a boring
speaker who can't engage an audience.

I like my presentations to be simple and effect-free; I don't want the
audience to be distracted from my leaping and capering about.
Just to see how it works


## The Vigenere cipher in haskell {#the-vigenere-cipher-in-haskell}

Programming the Vigenère cipher is my go-to problem when learning a new
language. It's only ever a few lines of code, but it's a pleasant way of
getting to grips with some of the basics of syntax. For the past few
weeks I've been wrestling with [Haskell](https://www.haskell.org), and
I've now got to the stage where a Vigenère program is in fact pretty
easy.

As you know, the Vigenère cipher works using a plaintext and a keyword,
which is repeated as often as need be:

```text
T H I S I S T H E P L A I N T E X T
K E Y K E Y K E Y K E Y K E Y K E Y
```

The corresponding letters are added modulo 26 (using the values A=0,
B=1, C=2, and on up to Z=25), then converted back to letters again. So
for the example above, we have these corresponding values:

```text
19   7   8  18   8  18  19   7   4  15  11   0   8  13  19   4  23  19
10   4  24  10   4  24  10   4  24  10   4  24  10   4  24  10   4  24
```

Adding modulo 26 and converting back to letters:

```text
3  11   6   2  12  16   3  11   2  25  15  24  18  17  17
D   L   G   C   M   Q   D   L   C   Z   P   Y   S   R   R
```

gives us the ciphertext.

The Vigenère cipher is historically important as it is one of the first
cryptosystems where a single letter may be encrypted to different
characters in the ciphertext. For example, the two "S"s are encrypted to
"C" and "Q"; the first and last "T"s are encrypted to "D" and "R". For
this reason the cipher was considered unbreakable - as indeed it was for
a long time - and was known to the French as _le chiffre
indéchiffrable_ - the unbreakable cipher. It was broken in 1863. See the
[Wikipedia page](https://en.wikipedia.org/wiki/Vigenère_cipher) for
more history.

Suppose the length of the keyword is . Then the -th character of the
plaintext will correspond to the character of the keyword (assuming a
zero-based indexing). Thus the encryption can be defined as

\\[
c\_i = p\_i+k\_{i\pmod{n}}\pmod{26}
\\]

However, encryption can also be done without knowing the length of the
keyword, but by shifting the keyword each time - first letter to the
end - and simply taking the left-most letter. Like this:

```text
T H I S I S T H E P L A I N T E X T
K E Y
```

so "T"+"K" (modulo 26) is the first encryption. Then we shift the
keyword:

```text
T H I S I S T H E P L A I N T E X T
  E Y K
```

and "H"+"E" (modulo 26) is the second encrypted letter. Shift again:

```text
T H I S I S T H E P L A I N T E X T
    Y K E
```

for "I"+"Y"; shift again:

```text
T H I S I S T H E P L A I N T E X T
      K E Y
```

for "S"+"K". And so on.

This is almost trivial in Haskell. We need two extra functions from the
module `Data.Char`: `chr` which gives the character corresponding to the
ascii value, and `ord` which gives the ascii value of a character:

```haskell
λ> ord 'G'
71
λ> chr 88
'X'
```

So here's what might go into a little file called `vigenere.hs`:

```haskell
import Data.Char (ord,chr)

vige :: [Char] -> [Char] -> [Char]
vige [] k = []
vige p [] = []
vige (p:ps) (k:ks) = (encode p k):(vige ps (ks++[k]))
  where
    encode a b = chr $ 65 + mod (ord a + ord b) 26

vigd :: [Char] -> [Char] -> [Char]
vigd [] k = []
vigd p [] = []
vigd (p:ps) (k:ks) = (decode p k):(vigd ps (ks++[k]))
  where
    decode a b = chr $ 65 + mod (ord a - ord b) 26
```

And a couple of tests: the example from above, and the one on the
Wikipedia page:

```haskell
λ> vige "THISISTHEPLAINTEXT" "KEY"
"DLGCMQDLCZPYSRROBR"
λ> vige "ATTACKATDAWN" "LEMON"
"LXFOPVEFRNHR"
```

[//]: # "Exported with love from a post written in Org mode"
[//]: # "- https://github.com/kaushalmodi/ox-hugo"
