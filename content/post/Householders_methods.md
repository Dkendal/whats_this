+++
title = "Householder's methods"
author = ["Alasdair McAndrew"]
date = 2018-09-09
tags = ["mathematics", "algebra"]
draft = false
mathjax = true
+++

These are a class of root-finding methods; that is, for the numerical solution
of a single nonlinear equation,
developed by [Alston Scott
Householder](<https://en.wikipedia.org/wiki/Alston_Scott_Householder>)
in 1970. They may be considered a generalisation of the well known [Newton-Raphson
method](<https://en.wikipedia.org/wiki/Newton's_method>) (also known more simply
as _Newton's method_) defined by

\\[
x\leftarrow x-\frac{f(x)}{f'(x)}.
\\]

where the equation to be solved is \\(f(x)=0\\).

From a starting value \\(x\_0\\) a sequence of iterates can be generated by

\\[
x\_{n+1}=x\_n-\frac{f(x\_n)}{f'(x\_n)}.
\\]

As is well known, Newton's method exhibits _quadratic convergence_; that is, if
the sequence of iterates converges to a root value \\(r\\), then the
limit

\\[
\lim\_{n\to\infty}\frac{x\_{n+1}-r}{(x\_n-r)^2}
\\]

is finite.  This means, in effect, that the number of correct decimal places
doubles at each step.  Householder's method for a rate of convergence \\(d+1\\) is
defined by

\\[
x\leftarrow x-d\frac{(1/f)^{(d-1)}(x)}{(1/f)^{(d)}(x)}.
\\]

We show how this definition can be rewritten in terms of ratios of derivatives,
by using Python and its symbolic toolbox [SymPy](<https://www.sympy.org/en/index.html>).

We start by defining some variables and functions.

```python
from sympy import *
x = Symbol('x')
f = Function('f')(x)
```

Now we can define the first Householder formula, with \\(d=1\\):

```python
d = 1
H1 = x + d*diff(1/f,x,d-1)/diff(1/f,x,d)
H1
```

\\[
x-\frac{f(x)}{\frac{d}{dx}f(x)}
\\]

which is Newton's formula.  Now for \\(d=2\\):

```python
d = 2
H2 = x + d*diff(1/f,x,d-1)/diff(1/f,x,d)
H2
```

\\[
x - \frac{2 \frac{d}{d x} f{\left (x \right )}}{- \frac{d^{2}}{d x^{2}}  f{\left (x \right )} + \frac{2 \left(\frac{d}{d x} f{\left (x \right )}\right)^{2}}{f{\left (x \right )}}}
\\]

This is a mighty messy formula, but it can be greatly simplified by using ratios
of derivatives defined by

\\[
r\_k=\frac{f^{(d-1}(x)}{f^{(d)}(x)}
\\]
This means that
\\[
r\_1=\frac{f}{f'},\quad r\_2=\frac{f'}{f^{\prime\prime}}
\\]
To make the subsitution into the current expression above, we can use the
substitutions
\\[
f^{\prime\prime}=f'/r\_2,\quad f'=f/r\_1
\\]
to be done sequentially (first defining the new symbols)

```python
r_1,r_2,r_3 = symbols('r_1,r_2,r_3')
H2r = H2s.subs([(Derivative(f,x,2), Derivative(f,x)/r_2), (Derivative(f,x), f/r_1)]).simplify()
H2r
```

\\[
-\frac{2r\_1r\_1}{r\_1-2r\_2}
\\]
Dividing the top and bottom by \\(2r\_2\\) produces the formulation
\\[
\frac{r\_1}{1-\displaystyle{\frac{r\_1}{2r\_2}}}
\\]
and so Householder's method for \\(d=2\\) is defined by the recurrence
\\[
x\leftarrow x-\frac{r\_1}{1-\displaystyle{\frac{r\_1}{2r\_2}}}.
\\]
This is known as [Halley's
method](<https://en.wikipedia.org/wiki/Halley's_method>), after [Edmond
Halley](<https://en.wikipedia.org/wiki/Edmond_Halley>), also known for his comet.
This method has been called the most often rediscovered iteration formula in the
literature.

It would exhibit _cubic convergence_, which means that the number of correct
figures roughly triples at each step.

Apply the same sequence of steps for \\(d=3\\), and including the subsitution
\\[
f^{\prime\prime\prime} = f^{\prime\prime}/r\_3
\\]
produces the fourth order formula
\\[
x\leftarrow x-\frac{3 r\_{1} r\_{3} \left(2r\_{2} - r\_{1}\right)}{r\_{1}^{2} - 6 r\_{1} r\_{3} + 6 r\_{2} r\_{3}}
\\]


## A test {#a-test}

We'll use the equation
\\[
x^5+x-1=0
\\]
which has a root close to \\(0.7\\).  First Newton's method, which is the
Householder method of order \\(d=1\\), and we start by defining the symbol \\(x\\) and
the function \\(f\\):

```python
x = Symbol('x')
f = x**5+x-1
```

Next define the iteration of Newton's method, which can be turned into a function with the handy tool
`lambdify`:

```python
nr = lambdify(x, x - f/diff(f,x))
```

Now, a few iterations, and print them as strings:

```python
y = 0.7
ys = [y]
for i in range(10):
    y = N(nr(y),100)
    ys += [y]

for i in ys:
    print(str(i))

0.7
0.7599545557827765973613054484303575009107589721679687500000000000000000000000000000000000000000000000
0.7549197891599746887794253559985793967456078439525201893202319456623650882121929457935763902468565963
0.7548776691557956141971506438033504033307707534709697222674827264390889507161368160254597915269779252
0.7548776662466927739251146002523856449587324643131536407777773148939177229546284200355119465808326870
0.7548776662466927600495088963585290075677963335246916447723036615900830138144428153523526591809355834
0.7548776662466927600495088963585286918946066177727931439892839706462440390043279509776806970677946058
0.7548776662466927600495088963585286918946066177727931439892839706460806551280810907382270928422503037
0.7548776662466927600495088963585286918946066177727931439892839706460806551280810907382270928422503037
0.7548776662466927600495088963585286918946066177727931439892839706460806551280810907382270928422503037
0.7548776662466927600495088963585286918946066177727931439892839706460806551280810907382270928422503037
```

We can easily compute the number of correct decimal places each time by simply
finding the first place in each string where it differs from the previous one:

```python
for i in range(1,7):
    d = [ys[i][j] == ys[i+1][j] for j in range(102)]
    print(d.index(False)-2)
```

\begin{array}{l}
2\cr
3\cr
8\cr
16\cr
32\cr
66
\end{array}

and we see a remarkable closeness with doubling of the number of correct values
each iteration.

Now, the fourth order method, with \\(d=3\\):

```python
r1 = lambdify(x,g(x)/diff(g(x),x))
r2 = lambdify(x,diff(g(x),x)/diff(g(x),x,2))
r3 = lambdify(x,diff(g(x),x,2)/diff(g(x),x,3))
h3 = lambdify(x,x-3*r1(x)*r3(x)*(2*r2(x)-r1(x))/(r1(x)**2-6*r1(x)*r3(x)+6*r2(x)*r3(x)))
```

Now we basically copy down the above commands, except that we'll use 1500 decimal
places instead of 100:

```python
y = 0.7
ys = [str(x)]
for i in range(10):
    y = N(h3(x),1500)
    ys += [str(y)]

for i in range(1,6):
    d = [xs[i][j] == xs[i+1][j] for j in range(1502)]
    print(d.index(False)-2)
```

\begin{array}{l}
4\\\\\\
19\\\\\\
76\\\\\\
308\\\\\\
1233
\end{array}

and we that the number of correct decimal places at each step is indeed
increased by a factor very close to 4.

[//]: # "Exported with love from a post written in Org mode"
[//]: # "- https://github.com/kaushalmodi/ox-hugo"
